

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>algorithms.homology_mod2 &mdash; HyperNetX 0.3.7 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
        <script type="text/javascript" src="../../_static/copybutton.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> HyperNetX
          

          
            
            <img src="../../_static/hnx_logo_smaller.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../overview/index.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installing HyperNetX</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../classes/modules.html">Hypergraphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../algorithms/modules.html">Algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../drawing/modules.html">Drawing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reports/modules.html">Reports</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../license.html">License</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">HyperNetX</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>algorithms.homology_mod2</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for algorithms.homology_mod2</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Homology and Smith Normal Form</span>
<span class="sd">==============================</span>
<span class="sd">The purpose of computing the Homology groups for data generated</span>
<span class="sd">hypergraphs is to identify data sources that correspond to interesting</span>
<span class="sd">features in the topology of the hypergraph.</span>

<span class="sd">The elements of one of these Homology groups are generated by $k$</span>
<span class="sd">dimensional cycles of relationships in the original data that are not</span>
<span class="sd">bound together by higher order relationships. Ideally, we want the</span>
<span class="sd">briefest description of these cycles; we want a minimal set of</span>
<span class="sd">relationships exhibiting interesting cyclic behavior. This minimal set</span>
<span class="sd">will be a bases for the Homology group.</span>

<span class="sd">The cyclic relationships in the data are discovered using a **boundary</span>
<span class="sd">map** represented as a matrix. To discover the bases we compute the</span>
<span class="sd">**Smith Normal Form** of the boundary map.</span>

<span class="sd">Homology Mod2</span>
<span class="sd">-------------</span>
<span class="sd">This module computes the homology groups for data represented as an</span>
<span class="sd">abstract simplicial complex with chain groups $\{C_k\}$ and $Z_2$ additions.</span>
<span class="sd">The boundary matrices are represented as rectangular matrices over $Z_2$.</span>
<span class="sd">These matrices are diagonalized and represented in Smith</span>
<span class="sd">Normal Form. The kernel and image bases are computed and the Betti</span>
<span class="sd">numbers and homology bases are returned.</span>

<span class="sd">Methods for obtaining SNF for Z/2Z are based on Ferrario&#39;s work:</span>
<span class="sd">http://www.dlfer.xyz/post/2016-10-27-smith-normal-form/</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">hypernetx</span> <span class="k">as</span> <span class="nn">hnx</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">hypernetx</span> <span class="k">import</span> <span class="n">HyperNetXError</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">defaultdict</span>
<span class="kn">import</span> <span class="nn">itertools</span> <span class="k">as</span> <span class="nn">it</span>
<span class="kn">import</span> <span class="nn">pickle</span>


<div class="viewcode-block" id="kchainbasis"><a class="viewcode-back" href="../../algorithms/algorithms.html#algorithms.homology_mod2.kchainbasis">[docs]</a><span class="k">def</span> <span class="nf">kchainbasis</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the set of k dimensional cells in the abstract simplicial</span>
<span class="sd">    complex associated with the hypergraph.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    h : hnx.Hypergraph</span>
<span class="sd">    k : int</span>
<span class="sd">        dimension of cell</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     : list</span>
<span class="sd">        an ordered list of kchains represented as tuples of length k+1</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    hnx.hypergraph.toplexes</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Method works best if h is simple [Berge], i.e. no edge contains another and there are no duplicate edges (toplexes).</span>
<span class="sd">    - Hypergraph node uids must be sortable.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">import</span> <span class="nn">itertools</span> <span class="k">as</span> <span class="nn">it</span>
    <span class="n">kchains</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">h</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">==</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">kchains</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">uidset</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">kchains</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">it</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">uidset</span><span class="p">),</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">kchains</span><span class="p">))</span></div>


<div class="viewcode-block" id="interpret"><a class="viewcode-back" href="../../algorithms/algorithms.html#algorithms.homology_mod2.interpret">[docs]</a><span class="k">def</span> <span class="nf">interpret</span><span class="p">(</span><span class="n">Ck</span><span class="p">,</span> <span class="n">arr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the data as represented in Ck associated with the arr</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Ck : list</span>
<span class="sd">        a list of k-cells being referenced by arr</span>
<span class="sd">    arr : np.array</span>
<span class="sd">        array of 0-1 vectors</span>

<span class="sd">    Returns</span>
<span class="sd">    ----</span>
<span class="sd">    : list</span>
<span class="sd">        list of k-cells referenced by data in Ck</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">output</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">vec</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ck</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vec</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">HyperNetXError</span><span class="p">(</span><span class="s1">&#39;elements of arr must have the same length as Ck&#39;</span><span class="p">)</span>
        <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">Ck</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vec</span><span class="p">))</span> <span class="k">if</span> <span class="n">vec</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">output</span></div>


<div class="viewcode-block" id="bkMatrix"><a class="viewcode-back" href="../../algorithms/algorithms.html#algorithms.homology_mod2.bkMatrix">[docs]</a><span class="k">def</span> <span class="nf">bkMatrix</span><span class="p">(</span><span class="n">km1basis</span><span class="p">,</span> <span class="n">kbasis</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the boundary map from $C_{k-1}$-basis to $C_k$ basis with</span>
<span class="sd">    respect to $Z_2$</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    km1basis : indexable iterable</span>
<span class="sd">        Ordered list of $k-1$ dimensional cell</span>
<span class="sd">    kbasis : indexable iterable</span>
<span class="sd">        Ordered list of $k$ dimensional cells</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bk : np.array</span>
<span class="sd">        boundary matrix in $Z_2$ stored as boolean</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">km1basis</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">kbasis</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">kbasis</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cell</span><span class="p">)):</span>
            <span class="n">face</span> <span class="o">=</span> <span class="n">cell</span><span class="p">[:</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">cell</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
            <span class="n">row</span> <span class="o">=</span> <span class="n">km1basis</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">face</span><span class="p">)</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">kbasis</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
            <span class="n">bk</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">bk</span></div>


<span class="k">def</span> <span class="nf">_rswap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">S</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Swaps ith and jth row of copy of S</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    i : int</span>
<span class="sd">    j : int</span>
<span class="sd">    S : np.array</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    N : np.array</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
    <span class="n">row</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
    <span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span>
    <span class="k">return</span> <span class="n">N</span>


<span class="k">def</span> <span class="nf">_cswap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">S</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Swaps ith and jth column of copy of S</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    i : int</span>
<span class="sd">    j : int</span>
<span class="sd">    S : np.array</span>
<span class="sd">        matrix</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    N : np.array</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">_rswap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">N</span>


<div class="viewcode-block" id="swap_rows"><a class="viewcode-back" href="../../algorithms/algorithms.html#algorithms.homology_mod2.swap_rows">[docs]</a><span class="k">def</span> <span class="nf">swap_rows</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Swaps ith and jth row of each matrix in args</span>
<span class="sd">    Returns a list of new matrices</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    i : int</span>
<span class="sd">    j : int</span>
<span class="sd">    args : np.arrays</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        list of copies of args with ith and jth row swapped</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">output</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">M</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_rswap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">M</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">output</span></div>


<div class="viewcode-block" id="swap_columns"><a class="viewcode-back" href="../../algorithms/algorithms.html#algorithms.homology_mod2.swap_columns">[docs]</a><span class="k">def</span> <span class="nf">swap_columns</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Swaps ith and jth column of each matrix in args</span>
<span class="sd">    Returns a list of new matrices</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    i : int</span>
<span class="sd">    j : int</span>
<span class="sd">    args : np.arrays</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        list of copies of args with ith and jth row swapped</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">output</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">M</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_cswap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">M</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">output</span></div>


<div class="viewcode-block" id="add_to_row"><a class="viewcode-back" href="../../algorithms/algorithms.html#algorithms.homology_mod2.add_to_row">[docs]</a><span class="k">def</span> <span class="nf">add_to_row</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Replaces row i with logical xor between row i and j</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    M : np.array</span>
<span class="sd">    i : int</span>
<span class="sd">        index of row being altered</span>
<span class="sd">    j : int</span>
<span class="sd">        index of row being added to altered</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    N : np.array</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
    <span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">N</span></div>


<div class="viewcode-block" id="add_to_column"><a class="viewcode-back" href="../../algorithms/algorithms.html#algorithms.homology_mod2.add_to_column">[docs]</a><span class="k">def</span> <span class="nf">add_to_column</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Replaces column i (of M) with logical xor between column i and j</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    M : np.array</span>
<span class="sd">        matrix</span>
<span class="sd">    i : int</span>
<span class="sd">        index of column being altered</span>
<span class="sd">    j : int</span>
<span class="sd">        index of column being added to altered</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    N : np.array</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">add_to_row</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span></div>


<div class="viewcode-block" id="logical_dot"><a class="viewcode-back" href="../../algorithms/algorithms.html#algorithms.homology_mod2.logical_dot">[docs]</a><span class="k">def</span> <span class="nf">logical_dot</span><span class="p">(</span><span class="n">ar1</span><span class="p">,</span> <span class="n">ar2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the boolean equivalent of the dot product mod 2 on two 1-d arrays of</span>
<span class="sd">    the same length.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ar1 : numpy.ndarray</span>
<span class="sd">        1-d array</span>
<span class="sd">    ar2 : numpy.ndarray</span>
<span class="sd">        1-d array</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : bool</span>
<span class="sd">        boolean value associated with dot product mod 2</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    HyperNetXError</span>
<span class="sd">        If arrays are not of the same length an error will be raised.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ar1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ar2</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">HyperNetXError</span><span class="p">(</span><span class="s1">&#39;logical_dot requires two 1-d arrays of the same length&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">ar1</span><span class="p">,</span> <span class="n">ar2</span><span class="p">))</span></div>


<div class="viewcode-block" id="logical_matmul"><a class="viewcode-back" href="../../algorithms/algorithms.html#algorithms.homology_mod2.logical_matmul">[docs]</a><span class="k">def</span> <span class="nf">logical_matmul</span><span class="p">(</span><span class="n">mat1</span><span class="p">,</span> <span class="n">mat2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the boolean equivalent of matrix multiplication mod 2 on two</span>
<span class="sd">    binary arrays stored as type boolean</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mat1 : np.ndarray</span>
<span class="sd">        2-d array of boolean values</span>
<span class="sd">    mat2 : np.ndarray</span>
<span class="sd">        2-d array of boolean values</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mat : np.ndarray</span>
<span class="sd">        boolean matrix equivalent to the mod 2 matrix multiplication of the</span>
<span class="sd">        matrices as matrices over Z/2Z</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    HyperNetXError</span>
<span class="sd">        If inner dimensions are not equal an error will be raised.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">L1</span><span class="p">,</span> <span class="n">R1</span> <span class="o">=</span> <span class="n">mat1</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">L2</span><span class="p">,</span> <span class="n">R2</span> <span class="o">=</span> <span class="n">mat2</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">R1</span> <span class="o">!=</span> <span class="n">L2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">HyperNetXError</span><span class="p">(</span><span class="s2">&quot;logical_matmul called for matrices with inner dimensions mismatched&quot;</span><span class="p">)</span>

    <span class="n">mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">L1</span><span class="p">,</span> <span class="n">R2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">mat2T</span> <span class="o">=</span> <span class="n">mat2</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">L1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mat1</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">R2</span><span class="p">):</span>
                <span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">logical_dot</span><span class="p">(</span><span class="n">mat1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">mat2T</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">R2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mat</span></div>


<div class="viewcode-block" id="matmulreduce"><a class="viewcode-back" href="../../algorithms/algorithms.html#algorithms.homology_mod2.matmulreduce">[docs]</a><span class="k">def</span> <span class="nf">matmulreduce</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Recursively applies a &#39;logical multiplication&#39; to a list of boolean arrays.</span>

<span class="sd">    For arr = [arr[0],arr[1],arr[2]...arr[n]] returns product arr[0]arr[1]...arr[n]</span>
<span class="sd">    If reverse = True, returns product arr[n]arr[n-1]...arr[0]</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : list of np.array</span>
<span class="sd">        list of nxm matrices represented as np.array</span>
<span class="sd">    reverse : bool, optional</span>
<span class="sd">        order to multiply the matrices</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    P : np.array</span>
<span class="sd">        Product of matrices in the list</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>
        <span class="n">items</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">items</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">))</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">items</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">items</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">logical_matmul</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">P</span></div>


<div class="viewcode-block" id="logical_matadd"><a class="viewcode-back" href="../../algorithms/algorithms.html#algorithms.homology_mod2.logical_matadd">[docs]</a><span class="k">def</span> <span class="nf">logical_matadd</span><span class="p">(</span><span class="n">mat1</span><span class="p">,</span> <span class="n">mat2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the boolean equivalent of matrix addition mod 2 on two</span>
<span class="sd">    binary arrays stored as type boolean</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mat1 : np.ndarray</span>
<span class="sd">        2-d array of boolean values</span>
<span class="sd">    mat2 : np.ndarray</span>
<span class="sd">        2-d array of boolean values</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mat : np.ndarray</span>
<span class="sd">        boolean matrix equivalent to the mod 2 matrix addition of the</span>
<span class="sd">        matrices as matrices over Z/2Z</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    HyperNetXError</span>
<span class="sd">        If dimensions are not equal an error will be raised.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">S1</span> <span class="o">=</span> <span class="n">mat1</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">S2</span> <span class="o">=</span> <span class="n">mat2</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">S1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">S1</span> <span class="o">!=</span> <span class="n">S2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">HyperNetXError</span><span class="p">(</span><span class="s2">&quot;logical_matadd called for matrices with different dimensions&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">S1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">S1</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">mat</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="n">mat1</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">mat2</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">S1</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">jdx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">S1</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">mat</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="n">jdx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="n">mat1</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="n">jdx</span><span class="p">],</span> <span class="n">mat2</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="n">jdx</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">mat</span></div>


<span class="c1"># Convenience methods for computing Smith Normal Form</span>
<span class="c1"># All of these operations have themselves as inverses</span>

<span class="k">def</span> <span class="nf">_sr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">L</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">swap_rows</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_sc</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">R</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">swap_columns</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_ar</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">L</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">add_to_row</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">add_to_row</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_ac</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">R</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">add_to_column</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">add_to_column</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_get_next_pivot</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determines the first r,c indices in the submatrix of M starting</span>
<span class="sd">    with row s1 and column s2 index (row,col) that is nonzero,</span>
<span class="sd">    if it exists.</span>

<span class="sd">    Search starts with the s2th column and looks for the first nonzero</span>
<span class="sd">    s1 row. If none is found, search continues to the next column and so</span>
<span class="sd">    on.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    M : np.array</span>
<span class="sd">        matrix represented as np.array</span>
<span class="sd">    s1 : int</span>
<span class="sd">        index of row position to start submatrix of M</span>
<span class="sd">    s2 : int, optional, default = s1</span>
<span class="sd">        index of column position to start submatrix of M</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    (r,c) : tuple of int or None</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># find the next nonzero pivot to put in s,s spot for Smith Normal Form</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">s2</span><span class="p">:</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="n">s1</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">M</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">None</span>


<div class="viewcode-block" id="smith_normal_form_mod2"><a class="viewcode-back" href="../../algorithms/algorithms.html#algorithms.homology_mod2.smith_normal_form_mod2">[docs]</a><span class="k">def</span> <span class="nf">smith_normal_form_mod2</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the invertible transformation matrices needed to compute the</span>
<span class="sd">    Smith Normal Form of M modulo 2</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    M : np.array</span>
<span class="sd">        a rectangular matrix with data type bool</span>
<span class="sd">    track : bool</span>
<span class="sd">        if track=True will print out the transformation as Z/2Z matrix as it</span>
<span class="sd">        discovers L[i] and R[j]</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    L, R, S, Linv : np.arrays</span>
<span class="sd">        LMR = S is the Smith Normal Form of the matrix M.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    Given a mxn matrix $M$ with</span>
<span class="sd">    entries in $Z_2$ we start with the equation: $L M R = S$, where</span>
<span class="sd">    $L = I_m$, and $R=I_n$ are identity matrices and $S = M$. We</span>
<span class="sd">    repeatedly apply actions to the left and right side of the equation</span>
<span class="sd">    to transform S into a diagonal matrix.</span>
<span class="sd">    For each action applied to the left side we apply its inverse</span>
<span class="sd">    action to the right side of I_m to generate $L^{-1}$.</span>
<span class="sd">    Finally we verify:</span>
<span class="sd">    $L M R = S$ and  $LLinv = I_m$.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">S</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
    <span class="n">dimL</span><span class="p">,</span> <span class="n">dimR</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># initialize left and right transformations with identity matrices</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">dimL</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">dimR</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">Linv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">dimL</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">dimL</span><span class="p">,</span> <span class="n">dimR</span><span class="p">)):</span>
        <span class="c1"># Find index pair (rdx,cdx) with value 1 in submatrix M[s:,s:]</span>
        <span class="n">pivot</span> <span class="o">=</span> <span class="n">_get_next_pivot</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pivot</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rdx</span><span class="p">,</span> <span class="n">cdx</span> <span class="o">=</span> <span class="n">pivot</span>
        <span class="c1"># Swap rows and columns as needed so that 1 is in the s,s position</span>
        <span class="k">if</span> <span class="n">rdx</span> <span class="o">&gt;</span> <span class="n">s</span><span class="p">:</span>
            <span class="n">S</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">_sr</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">rdx</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
            <span class="n">Linv</span> <span class="o">=</span> <span class="n">swap_columns</span><span class="p">(</span><span class="n">rdx</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">Linv</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">cdx</span> <span class="o">&gt;</span> <span class="n">s</span><span class="p">:</span>
            <span class="n">S</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">_sc</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">cdx</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
        <span class="c1"># add sth row to every row with 1 in sth column &amp; sth column to every column with 1 in sth row</span>
        <span class="n">row_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dimL</span><span class="p">)</span> <span class="k">if</span> <span class="n">S</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">rdx</span> <span class="ow">in</span> <span class="n">row_indices</span><span class="p">:</span>
            <span class="n">S</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">_ar</span><span class="p">(</span><span class="n">rdx</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
            <span class="n">Linv</span> <span class="o">=</span> <span class="n">add_to_column</span><span class="p">(</span><span class="n">Linv</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">rdx</span><span class="p">)</span>
        <span class="n">column_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">jdx</span> <span class="k">for</span> <span class="n">jdx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dimR</span><span class="p">)</span> <span class="k">if</span> <span class="n">S</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">jdx</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">cdx</span> <span class="ow">in</span> <span class="n">column_indices</span><span class="p">:</span>
            <span class="n">S</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">_ac</span><span class="p">(</span><span class="n">cdx</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">L</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">Linv</span></div>


<div class="viewcode-block" id="reduced_row_echelon_form_mod2"><a class="viewcode-back" href="../../algorithms/algorithms.html#algorithms.homology_mod2.reduced_row_echelon_form_mod2">[docs]</a><span class="k">def</span> <span class="nf">reduced_row_echelon_form_mod2</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the invertible transformation matrices needed to compute</span>
<span class="sd">    the reduced row echelon form of M modulo 2</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    M : np.array</span>
<span class="sd">        a rectangular matrix with elements in $Z_2$</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    L, S, Linv : np.arrays</span>
<span class="sd">        LM = S where S is the reduced echelon form of M</span>
<span class="sd">        and M = LinvS</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
    <span class="n">dimL</span><span class="p">,</span> <span class="n">dimR</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># method with numpy</span>
    <span class="n">Linv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">dimL</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">dimL</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="n">s2</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">s1</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">s2</span> <span class="o">&lt;=</span> <span class="n">dimR</span> <span class="ow">and</span> <span class="n">s1</span> <span class="o">&lt;=</span> <span class="n">dimL</span><span class="p">:</span>
        <span class="c1"># Find index pair (rdx,cdx) with value 1 in submatrix M[s1:,s2:]</span>
        <span class="c1"># look for the first 1 in the s2 column</span>
        <span class="n">pivot</span> <span class="o">=</span> <span class="n">_get_next_pivot</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">pivot</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">L</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">Linv</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rdx</span><span class="p">,</span> <span class="n">cdx</span> <span class="o">=</span> <span class="n">pivot</span>
            <span class="k">if</span> <span class="n">rdx</span> <span class="o">&gt;</span> <span class="n">s1</span><span class="p">:</span>
                <span class="c1"># Swap rows as needed so that 1 leads the row</span>
                <span class="n">S</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">_sr</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">rdx</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
                <span class="n">Linv</span> <span class="o">=</span> <span class="n">swap_columns</span><span class="p">(</span><span class="n">rdx</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">Linv</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># add s1th row to every nonzero row</span>
            <span class="n">row_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dimL</span><span class="p">)</span> <span class="k">if</span> <span class="n">idx</span> <span class="o">!=</span> <span class="n">s1</span> <span class="ow">and</span> <span class="n">S</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="n">cdx</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">row_indices</span><span class="p">:</span>
                <span class="n">S</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">_ar</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
                <span class="n">Linv</span> <span class="o">=</span> <span class="n">add_to_column</span><span class="p">(</span><span class="n">Linv</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
            <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">s1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cdx</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">L</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">Linv</span></div>


<div class="viewcode-block" id="coset"><a class="viewcode-back" href="../../algorithms/algorithms.html#algorithms.homology_mod2.coset">[docs]</a><span class="k">def</span> <span class="nf">coset</span><span class="p">(</span><span class="n">im2</span><span class="p">,</span> <span class="n">bs</span><span class="o">=</span><span class="p">[],</span> <span class="n">shortest</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate the coset represented by bs, if bs=None</span>
<span class="sd">    returns the boundary group</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    im2 : np.array</span>
<span class="sd">        columns form a basis for the boundary group</span>
<span class="sd">    bs : np.array</span>
<span class="sd">        boolean vector from projection of kernel on cokernel</span>
<span class="sd">    shortest : bool</span>
<span class="sd">        if True then only representatives of the coset containing</span>
<span class="sd">        the smallest number of $k$-cells will be returned</span>
<span class="sd">        else all elements of the coset will be returned</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     : list</span>
<span class="sd">        list of elements of the coset of interest</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    coset() is a very inefficient method for all but small examples.</span>
<span class="s2">    &quot;&quot;&quot;</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">im2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="n">image_basis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">im2</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="n">image_basis</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">coset</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">sh_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">bs</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">alpha</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">product</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">repeat</span><span class="o">=</span><span class="n">dim</span><span class="p">):</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="o">.</span><span class="n">reduce</span><span class="p">([</span><span class="n">a</span> <span class="o">*</span> <span class="n">image_basis</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">alpha</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="n">bs</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">shortest</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span> <span class="o">==</span> <span class="n">sh_len</span><span class="p">:</span>
                <span class="n">coset</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">sh_len</span><span class="p">:</span>
                <span class="n">coset</span> <span class="o">=</span> <span class="p">[</span><span class="n">temp</span><span class="p">]</span>
                <span class="n">sh_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coset</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">coset</span></div>


<div class="viewcode-block" id="homology_basis"><a class="viewcode-back" href="../../algorithms/algorithms.html#algorithms.homology_mod2.homology_basis">[docs]</a><span class="k">def</span> <span class="nf">homology_basis</span><span class="p">(</span><span class="n">bd</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shortest</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute a basis for the kth-homology group with boundary</span>
<span class="sd">    matrices given by bd</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    bd : dict</span>
<span class="sd">        dict of k-boundary matrices keyed on k,k+1</span>

<span class="sd">    k : int</span>
<span class="sd">        k must be an integer greater than 0</span>
<span class="sd">        bd must have keys for k, and k+1</span>
<span class="sd">    C : list, optional</span>
<span class="sd">        list of k-cells used to interpret the generators</span>
<span class="sd">        bd[k] is boundary matrix with rows and columns indexed by</span>
<span class="sd">        k-1 and k cells. C is a list of k chains ordered</span>
<span class="sd">        to match the column index of bd[k]</span>
<span class="sd">    shortest : bool, optional</span>
<span class="sd">        option to look for shortest basis using boundaries</span>
<span class="sd">        *Warning*: This is only good for very small examples</span>
<span class="sd">    log : str, optional</span>
<span class="sd">        path to logfile where intermediate data should be</span>
<span class="sd">        pickled and stored</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : list or dict</span>
<span class="sd">        list of generators as 0-1 tuples, if C then generators will be</span>
<span class="sd">        k-chains</span>
<span class="sd">        if shortest then returns a dictionary of shortest cycles for each coset.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">L1</span><span class="p">,</span> <span class="n">R1</span><span class="p">,</span> <span class="n">S1</span><span class="p">,</span> <span class="n">L1inv</span> <span class="o">=</span> <span class="n">smith_normal_form_mod2</span><span class="p">(</span><span class="n">bd</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
    <span class="n">L2</span><span class="p">,</span> <span class="n">R2</span><span class="p">,</span> <span class="n">S2</span><span class="p">,</span> <span class="n">L2inv</span> <span class="o">=</span> <span class="n">smith_normal_form_mod2</span><span class="p">(</span><span class="n">bd</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>

    <span class="n">rank1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">S1</span><span class="p">)</span>
    <span class="n">rank2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">S2</span><span class="p">)</span>
    <span class="n">nullity1</span> <span class="o">=</span> <span class="n">S1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">rank1</span>
    <span class="n">betti1</span> <span class="o">=</span> <span class="n">S1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">rank1</span> <span class="o">-</span> <span class="n">rank2</span>
    <span class="n">cokernel2_dim</span> <span class="o">=</span> <span class="n">S1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">rank2</span>

    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Summary: </span><span class="se">\n</span><span class="s1">rank</span><span class="si">{k}</span><span class="s1"> = </span><span class="si">{rank1}</span><span class="se">\n</span><span class="s1">rank{k+1} = </span><span class="si">{rank2}</span><span class="se">\n</span><span class="s1">nullity</span><span class="si">{k}</span><span class="s1"> = </span><span class="si">{nullity1}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="n">ker1</span> <span class="o">=</span> <span class="n">R1</span><span class="p">[:,</span> <span class="n">rank1</span><span class="p">:]</span>
    <span class="n">im2</span> <span class="o">=</span> <span class="n">L2inv</span><span class="p">[:,</span> <span class="p">:</span><span class="n">rank2</span><span class="p">]</span>
    <span class="n">cokernel2</span> <span class="o">=</span> <span class="n">L2inv</span><span class="p">[:,</span> <span class="n">rank2</span><span class="p">:]</span>
    <span class="n">cokproj2</span> <span class="o">=</span> <span class="n">L2</span><span class="p">[</span><span class="n">rank2</span><span class="p">:,</span> <span class="p">:]</span>

    <span class="n">proj</span> <span class="o">=</span> <span class="n">matmulreduce</span><span class="p">([</span><span class="n">cokernel2</span><span class="p">,</span> <span class="n">cokproj2</span><span class="p">,</span> <span class="n">ker1</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="c1">######</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">proj</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">proj</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">reduced_row_echelon_form_mod2</span><span class="p">(</span><span class="n">proj</span><span class="p">)</span>
    <span class="n">proj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">proj</span><span class="p">)</span>
    <span class="n">proj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">row</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">proj</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">row</span><span class="p">)])</span>
    <span class="c1"># print(f&#39;hom basis reps: {proj*1}\n&#39;)</span>
    <span class="n">basis</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">shortest</span><span class="p">:</span>
        <span class="n">shortest_basis</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">bs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">proj</span><span class="p">):</span>
            <span class="n">shortest_basis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coset</span><span class="p">(</span><span class="n">im2</span><span class="p">,</span> <span class="n">bs</span><span class="o">=</span><span class="n">bs</span><span class="p">,</span> <span class="n">shortest</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">C</span><span class="p">:</span>
            <span class="n">basis</span> <span class="o">=</span> <span class="p">[</span><span class="n">interpret</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">sb</span><span class="p">)</span> <span class="k">for</span> <span class="n">sb</span> <span class="ow">in</span> <span class="n">shortest_basis</span><span class="p">]</span>

        <span class="n">proj</span> <span class="o">=</span> <span class="n">shortest_basis</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">C</span><span class="p">:</span>
            <span class="n">basis</span> <span class="o">=</span> <span class="n">interpret</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">proj</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">basis</span> <span class="o">=</span> <span class="n">proj</span>
    <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">logdict</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">))</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">logdict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">logdict</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;k&#39;</span><span class="p">:</span> <span class="n">k</span><span class="p">,</span>
                        <span class="n">f</span><span class="s1">&#39;betti</span><span class="si">{k}</span><span class="s1">&#39;</span><span class="p">:</span> <span class="n">betti1</span><span class="p">,</span>
                        <span class="s1">&#39;ker&#39;</span><span class="p">:</span> <span class="n">ker1</span><span class="p">,</span>
                        <span class="s1">&#39;im&#39;</span><span class="p">:</span> <span class="n">im2</span><span class="p">,</span>
                        <span class="s1">&#39;proj&#39;</span><span class="p">:</span> <span class="n">proj</span><span class="p">,</span>
                        <span class="s1">&#39;basis&#39;</span><span class="p">:</span> <span class="n">basis</span><span class="p">})</span>
        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">logdict</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">basis</span></div>


<div class="viewcode-block" id="hypergraph_homology_basis"><a class="viewcode-back" href="../../algorithms/algorithms.html#algorithms.homology_mod2.hypergraph_homology_basis">[docs]</a><span class="k">def</span> <span class="nf">hypergraph_homology_basis</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">shortest</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the kth-homology group mod 2 for the ASC</span>
<span class="sd">    associated with the hypergraph h.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    h : hnx.Hypergraph</span>
<span class="sd">    k : int</span>
<span class="sd">        k must be an integer greater than 0</span>
<span class="sd">    shortest : bool, optional</span>
<span class="sd">        option to look for shortest basis using boundaries</span>
<span class="sd">        only good for very small examples</span>
<span class="sd">    log : str, optional</span>
<span class="sd">        path to logfile where intermediate data should be</span>
<span class="sd">        pickled and stored</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : list</span>
<span class="sd">        list of generators as k-chains</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">max_dim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">h</span><span class="o">.</span><span class="n">edges</span><span class="p">()])</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">max_dim</span> <span class="ow">or</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;wrong dim&#39;</span>
    <span class="n">C</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">kchainbasis</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
    <span class="n">bd</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">bd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bkMatrix</span><span class="p">(</span><span class="n">C</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">logdict</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">))</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">logdict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">logdict</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;maxdim&#39;</span><span class="p">:</span> <span class="n">max_dim</span><span class="p">,</span>
                        <span class="s1">&#39;kchains&#39;</span><span class="p">:</span> <span class="n">C</span><span class="p">,</span>
                        <span class="s1">&#39;bd&#39;</span><span class="p">:</span> <span class="n">bd</span><span class="p">,</span> <span class="p">})</span>
        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">logdict</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">homology_basis</span><span class="p">(</span><span class="n">bd</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="n">C</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">shortest</span><span class="o">=</span><span class="n">shortest</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">)</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018 Battelle Memorial Institute

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>